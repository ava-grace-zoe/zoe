import { Subscribe } from '@lib/subscriber';
import ActionDispatcher from '@src/component/state/ActionDispatcher';
import StateAcquirer from '@src/component/state/StateAcquirer';
import StateDriver from '@src/component/state/StateDriver';
import { OriginState, Reducers } from '@src/types';
import {
  emptyJson,
  getFullStateKey,
  nodeUtil,
  resolvePromise,
} from '@src/util';
import { BaseComponent } from '.';
import ReducerInitState from './state/ReducerInitState';
import StateRegistry from './state/StateRegistry';

/**
 * T 为action type类型
 *
 * D 为 payload 的类型
 *
 * K 为 state key 类型
 *
 * V 为 state value类型
 *
 * state: Record<K, V>
 */
export default abstract class StateComponent<
  T extends string = string,
  D = any,
  K extends string = string,
  V = any,
> extends BaseComponent {
  public readonly subscribe: (subscriber: Subscribe) => void;

  protected isFirstRendering = true;
  protected ignoreNodeActiveInHierarchy = false;
  protected isTransition = false;
  protected isUpdateRendering = true;
  private isCanPublish = false;

  private defaultState: Record<K, V> = emptyJson as Record<K, V>;
  private readonly reducerKeys: K[];
  private reducersKeyToFullKeyMap: Record<K, string>;

  private unCompressKey = '';
  private reducersKeyToFullUnCompressKeyMap: Record<K, string>;

  private actionDispatcher: ActionDispatcher<T, D, K, V>;
  private stateDriver: StateDriver<T, D, K, V>;
  private stateAcquirer: StateAcquirer<T, D, K, V>;
  private stateRegistry: StateRegistry<T, D, K, V>;
  private reducerInitState: ReducerInitState<T, D, K, V>;

  public static getReducerKeys<T extends string>(
    context: StateComponent,
    reducers: Reducers,
  ): T[] {
    const template = context.constructor as any;
    if (template.reducerKeys) {
      return template.reducerKeys;
    }

    return (template.reducerKeys = Object.keys(reducers) as T[]);
  }

  private static getReducerTypes(
    context: StateComponent,
    reducers: Reducers,
    reducerKeys: string[],
  ): string[] {
    const template = context.constructor as any;
    if (template.reducerTypes) {
      return template.reducerTypes;
    }
    const reducerTypes: string[] = (template.reducerTypes = []);

    for (let i = 0, { length } = reducerKeys; i < length; i++) {
      reducerTypes.push(...Object.keys(reducers[reducerKeys[i]].types));
    }

    return reducerTypes;
  }

  constructor() {
    super();
    const { reducers }: { reducers: Reducers<T, D, K, V> } = this
      .constructor as any;

    const reducerKeys = (this.reducerKeys = StateComponent.getReducerKeys<K>(
      this as any,
      reducers,
    ));
    const reducerTypes = StateComponent.getReducerTypes(
      this as any,
      reducers,
      reducerKeys,
    );

    this.stateDriver = new StateDriver<T, D, K, V>(this, reducerKeys);
    this.actionDispatcher = new ActionDispatcher<T, D, K, V>(
      this,
      this.stateDriver,
      reducerTypes,
    );
    this.stateAcquirer = new StateAcquirer<T, D, K, V>(this, reducerKeys);
    this.stateRegistry = new StateRegistry<T, D, K, V>(
      this,
      this.stateDriver,
      reducers,
      reducerKeys,
    );
    this.reducerInitState = new ReducerInitState<T, D, K, V>(
      reducers,
      reducerKeys,
    );

    this.wrapperLifeCycle();
  }

  private wrapperLifeCycle(): void {
    const { __preload, onEnable, update } = this;
    this.__preload = () => {
      this.onPreload();
      __preload.call(this);
    };

    this.onEnable = () => {
      this.onPreEnable();
      onEnable && onEnable.call(this);
    };

    this.update = (dt: number) => {
      this.onPrevUpdate();
      update && update.call(this, dt);
    };
  }

  private getUnCompressUUIDByKey(key: string): string {
    return nodeUtil.getUnCompressUUIDByPath(
      this.getPath() + this.getCustomKey() + key,
    );
  }

  public getUnCompressKey(): string {
    let { unCompressKey } = this;
    if (!unCompressKey) {
      unCompressKey = this.unCompressKey = this.getUnCompressUUIDByKey('');
    }
    return unCompressKey;
  }

  protected __preload(): void {}

  private onPreload(): void {
    const rootComponent = this.getRootComponent();
    this.getKey();
    this.getUnCompressKey();

    if (this.stateRegistry.isRegistry()) {
      return;
    }

    this.stateRegistry.registry();
    try {
      this.onRegistryStateEvent();
    } finally {
      this.isCanPublish = rootComponent ? rootComponent.isPublish() : false;
    }
  }

  private onPreEnable(): void {
    if (!this.isCanPublish) {
      return;
    }
    this.isCanPublish = false;

    resolvePromise.then(this.stateDriver.publish.bind(this.stateDriver));
  }

  protected onWillDestroy(): void {
    this.stateRegistry.unRegistry();
  }

  protected onDestroy(): void {}

  /**
   * 绑定状态事件
   *
   * @param name  string 必选
   * @param callback  function 必选
   * @param context  any 可选
   */
  public onStateFieldChange(
    name: K,
    callback: () => void,
    context?: unknown,
  ): void {
    this.on(`${name}::StateChanged`, callback, context);
  }

  /**
   * @param name  string 必选
   * @param callback  function 可选
   * @param context  any 可选
   */
  public offStateFieldChange(
    name: K,
    callback?: () => void,
    context?: unknown,
  ): void {
    this.off(`${name}::StateChanged`, callback, context);
  }

  protected onPrevUpdate(): void {
    this.stateDriver.update();
  }

  protected dispatchAction(type: T, payload?: D): void {
    return this.actionDispatcher.dispatchAction(type, payload);
  }

  protected renderBeforeUpdate(): void {
    this.stateDriver.renderBeforeUpdate();
  }

  /**
   * 清除本地缓存
   */
  public clearLocalState(): void {
    this.stateDriver.clearLocalState();
  }

  public setDefaultState(defaultState: Readonly<Record<K, V>>): void {
    this.defaultState = defaultState;
  }

  public getDefaultState(): Readonly<Record<K, V>> {
    return this.defaultState;
  }

  /**
   * 获取实时状态
   *
   * @returns Record<K, V>
   */
  public getState(): Readonly<Record<K, V>> {
    return this.stateAcquirer.getState();
  }

  public getTrulyState(stateName: K, state: OriginState<T, V>): V {
    state = state || this.reducerInitState.getReducerInitState(stateName);

    let defaultState;
    if (state.status === 'init') {
      defaultState = this.getDefaultState()[stateName];
      this.trigger('stateInit', defaultState);
    }

    return defaultState ?? state.data;
  }

  /**
   * 判断当前数据是否为初始值
   *
   * @returns boolean
   */
  public isInitStateByName(stateName: K): boolean {
    const rootComponent = this.getRootComponent();
    if (rootComponent === null) {
      throw new Error(`There is no Root node`);
    }

    const { status } =
      this.filterStateByAllState(rootComponent.getAllState(), stateName) ||
      this.reducerInitState.getReducerInitState(stateName);

    return status === 'init';
  }

  public filterStateByAllState(
    allState: Readonly<Record<string, OriginState<string, any>>>,
    stateName: K,
  ): OriginState<string, any> {
    let state = allState[this.getStateFullNameByName(stateName)];
    if (state === undefined) {
      state = allState[this.getStateUnCompressFullNameByName(stateName)];
    }

    return state;
  }

  private getStateUnCompressFullNameByName(name: K): string {
    let { reducersKeyToFullUnCompressKeyMap } = this;
    if (reducersKeyToFullUnCompressKeyMap) {
      return reducersKeyToFullUnCompressKeyMap[name];
    }

    const { reducerKeys } = this;
    reducersKeyToFullUnCompressKeyMap = this.reducersKeyToFullUnCompressKeyMap =
      Object.create(null) as Record<K, string>;
    let reducerKey;
    const key = this.getUnCompressKey();
    for (let i = 0, { length } = reducerKeys; i < length; i++) {
      reducerKey = reducerKeys[i];
      reducersKeyToFullUnCompressKeyMap[reducerKey] = getFullStateKey(
        key,
        reducerKey,
      );
    }

    return reducersKeyToFullUnCompressKeyMap[name];
  }

  private getStateFullNameByName(name: K): string {
    let { reducersKeyToFullKeyMap } = this;
    if (reducersKeyToFullKeyMap) {
      return reducersKeyToFullKeyMap[name];
    }

    const { reducerKeys } = this;
    reducersKeyToFullKeyMap = this.reducersKeyToFullKeyMap = Object.create(
      null,
    ) as Record<K, string>;
    let reducerKey;
    const key = this.getKey();
    for (let i = 0, { length } = reducerKeys; i < length; i++) {
      reducerKey = reducerKeys[i];
      reducersKeyToFullKeyMap[reducerKey] = getFullStateKey(key, reducerKey);
    }

    return reducersKeyToFullKeyMap[name];
  }

  public getIsFirstRendering(): boolean {
    return this.isFirstRendering;
  }

  public getIgnoreNodeActiveInHierarchy(): boolean {
    return this.ignoreNodeActiveInHierarchy;
  }

  public getIsTransition(): boolean {
    return this.isTransition;
  }

  public getIsUpdateRendering(): boolean {
    return this.isUpdateRendering;
  }

  protected onRegistryStateEvent(): void {}
  protected abstract isStateEqual(nextState: V, prevState: V): boolean;
}
